### 강의 설명

**강의의 목표**

- 스프링이 제공하는 가치를 이해하고 사용하는 것
- IoC DI, SOLID 원칙 등에 대한 이해

**스프링의 핵심:** 객체 지향 프로그래밍을 하자



## 스프링이 나오게 된 배경

### Hibernate

- 2000년대 초반에 자바에서 만든 EJB(Enterprise Java Beans)라는 기술이 많이 쓰이고 있었음
- 자바에서 표준으로 정한 기술이었으며 트랜잭션 관리, 분산기술에 대한 지원이 잘되었음
- 하지만 이론적으로만 완벽하고 실제로 개발하기 너무 어렵다는 단점이 존재
- Entity bean이 사용하기 어렵자 오픈소스로 개발된 것이 Hibernate
- 자바는 이 Hibernate를 만든 사람을 영입하여 JPA라는 표준을 정제해서 만들어냄
  - JPA는 인터페이스고 이를 구현한 것이 Hibernate, Eclipselink 등..
  - 표준으로 제작되며 용어, API에 대해 필요한걸 논의하고 추가, 덜어내기 작업들이 이루어졌음



### 스프링의 역사

로드 존슨이 ejb의 문제를 지적하며 책을 작성

책에는 3만줄 정도의 코드가 예제로 들어가 있었으며, 이는 현재 스프링의 뼈대가 되는 코드들임

이를 본 유겐 휠러와 다른 개발자가 스프링을 오픈소스 프로젝트로 만들자는 제안을 하게됨.

스프링의 중심이 되는 부분은 대부분 유겐 휠러가 많이 만들었음



### 스프링 생태계

![image-20231001165909163](https://raw.githubusercontent.com/Neph3779/Blog-Image/forUpload/img/20231001165909.png)

- 스프링은 여러 기술의 집합
- 스프링 프레임워크와 스프링 부트는 필수적으로 사용되고 있으며 나머지는 필요에 따라 선택하여 사용함



스프링 프레임워크의 핵심 기술

- 스프링 DI 컨테이너, AOP, 이벤트, 기타



스프링 부트의 장점

- 메이저 라이브러리를 사용해도 스프링 사용에 따른 버전문제 없음
  - 메이저 라이브러리들의 버전 의존성알 알아서 관리하여 내려줌
- 서비스 운영 단계에서 필요한 모니터링 기능을 많이 지원해줌
- 스프링의 간결한 설정을 지원해줌
  - 스프링 부트 등장 이전에는 스프링을 통한 개발은 설정이 절반이다라는 말이 떠돌 정도로 설정이 복잡했었음



### 스프링이란?

스프링이라는 단어는

스프링 DI 컨테이너 기술을 말하기도 하고 (스프링 컨테이너)

스프링 프레임워크 자체를 말하기도 하고

스프링 부트, 스프링 프레임워크 등을 모두 포함한 생태계를 일컫기도 함



### 스프링 만든 이유?

> 모든 기술은 핵심 개념이 가장 중요, 모든 핵심 컨셉은 단순하게 시작하고 여기에 기술이 붙으면서 복잡해지는 것

**스프링의 핵심 컨셉**

- 스프링은 자바 언어 기반 프레임워크
- 자바 특징: 객체 지향 언어
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- **좋은 객체 지향 애플리케이션**을 개발할 수 있게 도와주는 프레임워크



## 좋은 객체 지향 프로그래밍이란?

- 추상화
- 캡슐화
- 상속
- 다형성



객체 지향 프로그래밍?

컴퓨터 프로그램의 명령어의 목록으로 보던 시각에서 벗어나

여러 개의 독립된 단위로 즉, 객체 들의 모임으로 파악하고자 하는 것

각각의 객체는 메시지를 주고받고 데이터를 처리함 (협력을 통해)

객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 소프트웨어 개발에서 많이 사용됨



컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법

다형성 polymorphism

진짜 다형성이란? 왜 중요한가?

자동차란 역할을 만들고 구현체를 분리한건

클라이언트가 내부 구조를 몰라도 되므로

자동차 세상을 확장할 수 있음

자동차 역할만 구현하면 되므로



클라이언트의 영향을 주지 않고

새로운 기능을 제공할 수있음

역할과 구현으로 구분해놨기 때문



인터페이스를 안정적으로 설계하는 것이 아주 중요함



한계

인터페이스 변경하면 클라, 서버 모두에게 큰 변경 발생



## SOLID 원칙

SOLID 원칙이란 클린코드로 유명한 로버트 마틴이 내세운 개발의 5가지 원칙을 정리한 것

### SRP

**Single responsibility principle**

- 하나의 클래스는 하나의 책임만 가져야 한다.
  - 하나의 책임의 기준? 모호한 측면 존재
  - 가장 중요한 기준은 "변경" 
  - 변경으로 인한 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
  - 계층이 잘 나눠져있는 이유: 단일 책임 원칙을 잘 지키기 위한 것



### OCP

**Open/Closed principle**

- 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다는 의미
- 즉, 다형성을 잘 활용하자는 말과도 같음
- 주입해주는 단계가 없다면 다형성을 사용했지만 OCP 원칙을 지킨 것이 아님
  - 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요한 이유
  - 이걸 해주는게 스프링 컨테이너



### LSP

**Liskov substitution principle**

- 인터페이스가 있을때 그에 대한 구현체를 그 기능을 잘 구현해야됨
- 컴파일 오류만이 아니라 기능의 오류가 없어야 함
- 규약을 기능적으로 잘 따르고, 보장해줘야된다는 의미



### ISP

**Interface segregation principle**

- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다
- 하나의 거대한 인터페이스 x
- ISP를 잘 지키면 인터페이스가 명확해지고 대체 가능성이 높아짐



### DIP

**Dependency Inversion Principle**

- 추상화에 의존해야지 구체화에 의존하면 안된다는 뜻
- 구현 클래스에 의존하지 말고 인터페이스에 의존해야함
- 인터페이스만 바라보고 실제 구현체는 몰라야 함
- 만약 구현체에 의존하게 되면 변경이 어려워짐



### 정리

객체 지향의 핵심은 **다형성**

하지만 다형성만으로는 쉽게 부품 갈아 끼우듯 개발할 수 없음 (OCP, DPI 위반)

이를 해결하기 위해 의존성 주입이 필요한데 이를 도와주는게 Spring Container



## 객체 지향 설계와 스프링

- 스프링은 DI Container를 제공함
- 클라이언트 코드의 변경 없이 기능 확장 가능
- 클라이언트 교체 없이 부품 교체하듯 확장 가능

**스프링이 없던 시절에는 OCP, DIP를 지키기 위해 할일이 너무 많았음**

### 인터페이스와 오버헤드

이상적으로는 모든 설계에 인터페이스를 부여하는 것이 바람직하나

인터페이스를 도입하면 추상화라는 비용이 발생하므로

기능 확장 가능성이 없는 경우, 비용을 쓰는것은 비효율적

구체 클래스를 직접 사용하다가 나중에 꼭 필요할때 리팩토링해서 인터페이스를 도입하는것도 하나의 방법

<br/>

> 이런걸 잘 고민하고 설계하는게 좋은 개발자이자, 좋은 아키텍트



## Java 문법

- Map<>
  - key value 쌍으로 구성된 리스트
  - Swift의 Dictionary와 유사
  - put과 get 메서드를 지원
- HashMap<>
  - synchronized 키워드: 메서드가 임계구역으로 설정되는 기능
  - HashMap은 synchronized 키워드가 붙어있지 않음 따라서 성능이 제일 좋음
    - 그러나 당연히 멀티 쓰레드 환경에서는 문제 발생
- ConcurrentHashMap<>
  - 멀티쓰레드 환경에서도 사용할 수 있도록 만든 Map
  - get할때는 synchronized 키워드 없고, put할때는 중간 메서드에 synchronized 붙어있음
  - get할때는 lock을 걸지 않고, put 할때에도 필요한 부분에만 lock을 걸어주는 편의성을 제공함

[참고한 글](https://devlog-wjdrbs96.tistory.com/269)



## IntelliJ 단축키

- command + 1
  - 왼쪽 탐색기 바로 사용 가능

## 회고

### Keep

- 50분 공부, 10분 휴식

### Problem

- 실습 했던 코드에 대한 보관방식 필요

### Try(Action Items)

- 