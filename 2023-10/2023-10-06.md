## Bean의 생명주기와 콜백 메서드

### 스프링 빈의 라이프사이클

- 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸 전 콜백 -> 스프링 종료
- 기본적으로는 모든 빈을 생성한 뒤, 의존관계 주입을 하는게 원칙이지만 생성 시점에 생성자에서 빈을 요구하는 경우는 의존관계 주입도 같이 이뤄지게 됨



### 생성과 초기화를 분리하자

- 서버에서 초기화는 단순히 내부 변수들을 할당하는것만 포함되지 않음
  - DB의 연결 작업, 소켓 연결 작업 등을 포함한 무겁고 복잡한 작업은 "빈 생성" 시점이 아닌 별도의 초기화 시점에 진행하는게 좋음
  - 초기화는 단순히 객체의 인스턴스화만 진행하는 것이 좋음



### 생명주기 콜백 

스프링은 의존관계 주입 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점 알려주는 다양한 방법이 있음

#### 인터페이스를 통해 사용하는 방법

- 스프링 초창기에 개발된 방법이며 현재는 거의 사용되지 않음
- UIKit에서 ViewDidLoad를 직접 오버라이딩하여 호출하듯, InitializingBean, DisposableBean를 직접 채택하고, 인터페이스에 정의된 메서드들을 오버라이딩하여 구현하는 방식
- 단점
  - 코드가 스프링의 전용 인터페이스에 의존하게됨
  - 초기화, 소멸 메서드의 이름을 변경할 수 없음
  - 내가 코드를 고칠 수 없는 (직접 해당 코드에 가서 저 인터페이스들을 채택시키고 내부에 메서드를 구현할 수 없는) 외부 라이브러리에 적용시킬 수 없음

#### 수동 Bean 등록시 각 시점의 메서드 이름을 직접 등록하는 방법

- 수동으로 빈을 등록할때 
  `@Bean(initMethod = "메서드 이름", destoryMethod = "메서드 이름 2")`
  이렇게 메서드 이름을 문자열로 직접 지정해주면 생성, 소멸 시점에 저 메서드가 각각 호출됨
- destoryMethod의 디폴트 값은 (inferred)로 등록되어있는데 스프링이 내부적으로 소멸 메서드로 보이는 메서드를 찾아 이를 실행시켜줌
- 장점
  - 스프링 빈이 스프링 코드에 의존하지 않음
  - 생성, 소멸 시점의 메서드 이름을 자유롭게 지정할 수 있음 (인터페이스 사용시 단점 보완)
  - 내부 코드를 고치는게 아니라 설정 정보를 바꿔주는 것이기 때문에 내부 코드를 건드릴 수 없는 외부 라이브러리를 사용할때 생성 소멸 시점을 캐치하기 수월함
- 단점
  - 수동 빈 등록이 필수
  - 메서드 이름을 직접 문자열로 등록해야됨

**사용 예시**

```java
@Configuration
static class AppConfig {
	@Bean(initMethod = "init")
	public AdaptyService adaptyService() {
	 return new Adaptyservice();
	}
}
```



#### 애노테이션을 활용하는 방법

- 최신 스프링에서 가장 권장하고 있는 방법
- `@PostConstruct`, `@PreDestory`라는 애노테이션을 생성 시점에 실행할 메서드, 소멸 시점에 실행할 메서드에 붙여주면 됨
- 장점
  - 위 애노테이션은 스프링에 종속적인 기술이 아닌 JSR-250이라는 자바 표준
    - 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다는 장점이 있음
  - 자동 빈 등록 방법과 같이 사용하기 좋음
- 단점
  - 외부 라이브러리에는 적용 불가



## 프로토타입 스코프

### Bean Scope

- Scope: 범위
  - 빈이 활동하는 범위
- Scope의 종류
  - Singleton
    - 한번 생성되면 생성된 하나의 빈이 모든 곳에서 사용됨
  - Prototype
    - 일회적으로 생성되며 다른 곳에서 요청할 경우 매번 새로운 객체를 생성



#### 문제상황

싱글톤 빈(이하 A)가 프로토 타입 빈(이하 B)를 사용하는 경우를 가정

프로그래머는 A를 사용할때마다 새롭게 생성된 B가 사용되길 원함

하지만 싱글톤 빈이 생성될때 프로토 타입 빈의 참조를 들고 있게 되어버리기 때문에

A 객체가 생성될때 함께 생성된 B의 객체가 사용됨 (클라이언트가 바뀌어도 새로 생성되지 않음)

<br/>

Q. 그럼 그냥 A가 B의 객체를 생성해서 쓰면 되는거 아닌가요?

A. 그러려면 생성할때 B의 구체타입을 알고 있어야 하는데 이는 OCP, DIP를 위반하는 일



#### 해결방법

- ApplicationContext를 주입받기
  - context를 직접 주입받고 getBean을 통해 빈을 매번 생성하는 방법
  - ApplicationContext를 주입받는 구조가 바람직하지 않으므로 사용되지 않는 방법
    - ApplicationContext 자체를 주입받게되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워짐 
    - 문제 상황은 DI가 아닌 DL(Dependency Lookup)이 필요한 상황

- ObjectProvider\<T\>

  - 지정한 T 타입의 빈을 컨테이너에서 대신 찾아 사용할 수 있도록 해주는 방식

  - DL이 필요한 현재 상황에 가장 적절한 사용법

  - 구체 타입을 지정해서 사용하는것도 아니니 DIP, OCP 원칙 준수 가능

  - 사용법

    - `ObjectProvider<SomeProtoTypeBean> someProtoTypeBeanProvider;`

    - `someProtoTypeBeanProvider.getObject();`



## 회고

### 잘한점

- 시간이 미뤄지긴 했지만 3시간어치의 공부를 해낸점

### 개선점

- 어제 밤 공부를 미뤄서 다음날에 보충하게 되었음
  - 원인
    - 퇴근 후 피로하여 쉬고 싶다는 생각이 강해진 것이 원인
  - 개선 방안
    - 저녁이 아닌 아침에 공부하기
      - 장점
        - 퇴근 후 피곤해서 공부 집중력이 떨어지는 문제 방지 가능
        - 상황상 늦게 퇴근하게 되는 경우에도 문제 없음
        - 적어도 퇴근한 뒤 잘때까지는 푹 쉴 수 있음
      - 단점
        - 7:00 ~ 10:00 까지 공부한다고 가정했을때 6:30에는 기상해야하는데 현실적으로 가능할지 의문
        - 일찍 일어남으로 인해 오히려 더 피곤하거나 졸릴 가능성 존재

