## Component Scan Filter

- 애노테이션을 가지고 ComponentScan에 넣을지 말지를 필터링 할 수 있음

```java
@ComponentScan(
  includeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class),
  excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyExcludeComponent.class)
)
```

이런식으로 필터로 제외, 포함 지정 가능

- FilterType에는 ANNOTATION, ASSIGNABLE_TYPE, ASPECTJ, REGEX, CUSTOM 등이 존재
- 하지만 웬만하면 필터링 없이 사용하는 방향을 택하는게 바람직함



## 빈 중복 등록과 충돌

### 하나의 빈이 중복되어 등록되는 경우

- 빈이 중복되어 등록되는 경우는 다음 두 가지 케이스가 존재
- 자동 빈 등록후 자동 빈 등록
  - 자동 빈 등록이 이중으로 되는 경우
  - 빈 이름을 직접 지정하는 경우에 발생 가능
  - 일어나면 스프링에서 예외를 발생시킴
- 수동 빈 등록후 자동 빈 등록
  - 수동으로 등록해놨는데 자동으로도 등록되어버린 경우
  - 수동으로 등록한 빈이 자동으로 등록한 빈을 그냥 오버라이딩 해버림 (덮어쓰기 해버림)
  - 스프링은 예외를 발생시키지 않지만 스프링부트는 예외를 발생시킴
    - 개발자가 의도적으로 수동 빈, 자동 빈 등록을 모두 해놨을 가능성이 적다 판단하는 것

### 빈 조회시 반환되는 타입이 여러개인 경우

- @AutoWired를 통해 주입받는 경우 타입을 통해 빈을 찾아주게됨
- 근데 해당 타입의 빈이 2개 이상인 경우가 존재함
  - 예를 들어 어떤 인터페이스 A를 준수하는 타입이 a, b 이렇게 두개가 있다고 칠때
  - a, b를 빈으로 선언하고 어딘가서 @AutoWired로 A를 요구하면 a, b 둘다 반환되어 에러 발생
  - 처음부터 a나 b로 요구하면 에러는 안생기지만 DIP를 위배하게되고, 유연성이 떨어짐
    - 역할에 의존해야되는데 구체적인 것에 의존해버리는 결과가 생기므로 DIP 위배

#### 해결방법

- 필드, 파라미터명을 통한 구분
  - 필드 혹은 파라미터의 이름을 구체타입의 이름처럼 지정하는 방식
  - @AutoWired가 타입을 통해 빈을 찾았을때 두개 이상의 결과를 얻게되면, 그 다음으로는 name을 가지고 조회하기 때문에 가능한 방식
- @Qualifier를 통한 구분
  - @Qualifier라는 추가 구분자를 붙여주는 방법
    - Tag와 유사
  - 빈 이름을 직접 변경하는건 아님
  - `@Qualifier("mainPolicy")` 같은 형태로 사용
- @Primary를 통한 우선순위 결정
  - 제일 자주 사용하는 방식
  - 여러개의 빈 중 @Primary 붙어있는걸 우선으로 선택하여 반환함

#### 현업에서는?

메인으로 사용할 객체에 Primary를 붙여두고,

서브로 사용할 곳에 Qualifier 붙여두었다가 

서브가 필요할때만 필요할때 Qualifier를 통해 가져오도록 코드를 수정

Primary랑 Qualifier가 맞붙으면 Qualifier가 더 구체적인 지정이므로 Qualifier가 승리



## 의존관계 자동 주입

- @AutoWired 애노테이션은 생성자 말고 필드, setter, method에다가도 붙일 수 있음
  - 하지만 생성자에만 붙여 쓰는게 구조상 가장 바람직함. 아래는 그 이유들
    - test시 mocking을 위해서
    - 주입받을 객체를 final로 선언하여 변경 가능성을 없앨 수 있음

> 참고: 당연하지만 @AutoWired는 해당 클래스가 Bean으로 등록 되어있어야지 동작



#### 스프링 라이프 사이클

1. 빈을 등록
2. 의존관계 주입

> 단, 빈 등록시 생성자에서 다른 빈을 요구하는 경우에는 먼저 필요한 빈을 등록후 해당 빈을 등록



### 의존성 주입 할지말지를 옵션으로 처리하는 방법

- 가끔은 의존성 주입이 되지 않은 상태로 작업을 수행해야 하는 경우도 있음
  - 아직 어떤 케이스인지는 모르겠다.
- @AutoWired(required = false)로 해두면 setter 자체가 호출되지 않음
- 필드를 @Nullable 애노테이션을 붙여 선언해두면 주입할 대상 없을때 null이 들어감
- 필드를 Optional<>로 선언한 경우엔 주입할 대상 없을때  Optional.empty가 들어감



###  Lombok 라이브러리

- @Getter @Setter @RequiredArgsConstructor @ToString 등 다양한 애노테이션을 지원
- Getter, Setter, 생성자 등을 내가 직접 코드로 치지 않아도 자동으로 내부에서 만들어주는 기능



### 특정 인터페이스 혹은 클래스에 속하는 빈을 모두 조회하기

- Map\<String, SomeInterface\> interfaceMap

- List\<SomeInterface\> interfaceList
- @AutoWired 애노테이션을 통해 저 값들을 주입받으면 자동으로 SomeInterface를 만족하는 모든 빈들을 찾아서 넣어줌
  - Map의 key값의 경우 해당 빈의 이름으로 등록됨



### 자동 빈 등록 vs 수동 빈 등록 뭘 써야할까?

- 대부분의 경우 자동빈을 선호
- 특히 @Controller @Service @Repository 등 유명 패턴에 대해서는 스프링 자체가 문법까지 지원하고 있음
  - well-known이다 -> 자동 빈 사용
  - 스프링, 스프링부트가 지원하는 로직들은 well-known인 것들이 대부분이므로 자동 빈 등록을 사용
- 수동빈을 쓰는 경우
  - 기술적인 문제를 해결하기 위한 코드 (기술 지원 객체)
  - AOP 등의 코드 전반에 영향을 주는 코드
  - 이 외의 사람이 직접 보고 해당 작업이 수행됨을 인지해야하는 경우들에 수동 빈 사용
    - 자동으로 등록해두면 눈에 잘 보이지 않기 때문에 눈에 확실히 보여야 하는 것들에 대해 수동 빈을 사용함
    - 자동으로 등록하고 싶다면 적어도 하나의 패키지에 모아두기



## IntelliJ 단축키

- command + F12
  - 자동 생성된 메서드를 포함해 해당 클래스의 모든 메서드의 목록을 보여주는 기능



## 회고

### Keep

- 집중이 안될때는 차라리 조금 오래 쉬고 다시 남은 공부 채우기

### Problem

- 확실히 퇴근하고 와서 하는 공부라 그런지 2시간 이후로 집중력이 바닥을 쳤음
  - 3시간만 채우면 원하는 양의 공부가 안될 것 같아 30분 정도 쉰 뒤 다시 공부를 마무리했음
- 매일 쓰는 회고에 KPT를 쓰는게 의미가 있는가에 대한 의문이 듦

### Try(Action Item)

- KPT 대신 잘한점 못한점 정도로 바꿔도 괜찮을 것 같다.
- 이번 강의를 다 듣고 나서 하루 정도 투자하여 배운 내용들을 바탕으로 간단한 예제 토이 프로젝트를 만들어서 깃허브에 올려봐도 좋을 것 같다.